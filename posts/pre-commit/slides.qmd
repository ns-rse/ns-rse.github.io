---
title: "Pre-commit : Protecting your future self"
author: "Neil Shephard"
email: "n.shephard@sheffield.ac.uk"
format:
  revealjs:
    theme: sky
    slide-number: true
    show-slide-number: speaker
    # embed-resources: true
    # standalone: true
footer: "**slides**: []() - **source** [github.com/ns-rse/ns-rse.github.io/](https://github.com/ns-rse/ns-rse.github.io/posts/pre-commit-slides.qmd)"
from: markdown+emoji
---

## Structure

+ (Very) brief Git version control
+ A digression into Linting and Testing
+ Git Hooks
+ `pre-commit` installation
+ `pre-commit` configuration
+ `pre-commit` demo.
+ `pre-commit.ci`
::: {.notes}
:::

## Git

![](https://imgs.xkcd.com/comics/git.png)
Source : [xkcd (1597) Git ](https://xkcd.com/1597/)
::: {.notes}
:::

## Git Workflow

+ Make a branch.
+ Edit some files.
+ Stage and **commit** changes.
+ Push to remote `origin`.
+ Make a pull request.
+ Merge changes into main.

::: {.notes}
:::

## Git Workflow (_cont._)

**TODO** - Show all of the graph!

<!-- See live preview at -->
<!-- https://mermaid.live/edit#pako:eNp1UbtuhDAQ_BXLEqJBJx5XJJS5SGmuS0uz2GtjgfHFGKII8e8xvkOJIsedZ2ZndjUrZYYjrWmSrGpUriYrSQcjr7jgkNYk5djOMs1I6jrUuCMtTLgDUrk3C7fOY2s6debzxcLIOpw84OyMWQAvRmvlrtAGOwHDhNtGtiRpxsOgGYl_LAiJ4jVpaFEKyKGhEaoSTPZFlIJ84ksepbzhAHHDNn9mMB1UG44gAsHNFh_yDllvZvcH_W1yVmBEfF_44OIn-bDSoMY7pNFKPKwfQwKqp8JfQhzI_b_kp-L0z9FcFOU5SrEqLysfTTPqQ3wi90Wvu7Choc6G7jIOtt_nN6-D2Zn3r5HROlRI5xsHh68KpAVN63t_322NsfU -->

```{mermaid}
%%| fig-height: 2
%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true,'showCommitLabel': true}} }%%
gitGraph
    commit
    commit
    commit
    commit
    commit
    branch feature
    checkout feature
    commit
    commit
    checkout main
    merge feature tag: "v0.1.1"
    commit
    commit
```

::: {.notes}
A typical workflow of a version controlled directory is that you would make a branch, typically from main, then edit or
add some files to the branch, stage and commit them, and then push them to the remote and make a pull request to merge
them into the main branch.
:::


## Linting and Testing

A digression...

+ Good practice to have tests in place for code.
+ Good practice to lint code & conform to Style Guides

::: {.notes}
We'll now take a short digression on good practices when writing code and look at testing and linting of code as these
are steps that are pre-requisites to using pre-commit.

When you write code it is sensible to write tests to ensure that your functions, methods and classes work as expected.

Similarly it is good practice to lint your code to ensure it conforms to style guides and remove any "smells".

We'll take a short digression to look at how these two steps work.
:::


## A simple :snake: function

[`sample.py`](sample.py)

```{.python}
import numpy as np
import pandas as pd

from pathlib import Path

def find_and_load_files(file_path: Union[str, Path], file_ext: str) -> List:
    """Recursively find files of the stated type along the given file path."""
    # We have a really long comment on this line just for demonstration purposes so that we can generate a few errors that need linting
    try:
        return Path(file_path).rglob(f"*{file_type}")
    except:
        raise
```

::: {.notes}
This is a simple function in Python that we'll use to demonstrate linting and tests. You don't need to be too familiar
with Python to understand and follow along but a quick explanation is that a few libraries are imported, then the
function find_and_load_files is defined, it takes two arguments a file path and a file type and it will try to
recursively find all files ending with the given extension along that path, and if an exception is encountered it is raised.
:::


## Testing


::: {.notes}
:::


## Linting

Lots of tools for linting...

* [black](https://github.com/psf/black) PEP8 compliance.
* [flake8](https://flake8.pycqa.org/en/latest/) PEP8 compliance.
* [pylint](https://pylint.pycqa.org/en/latest/index.html) PEP8 compliance, code smells and refactoring suggestions.
* [mypy](http://mypy-lang.org/) Typehint checking.

::: {.notes}
:::


## Linting manually...

```{.bash}
black sample.py
flake8 sample.py
pylint sample.py
mypy sample.py
```

::: {.notes}
If you were running linting manually then you would have to invoke each and run them against a specific file, or all
files in a project directory. The later might actually cause some problems because if you are working on an existing
code based which hasn't been linted already and these could potentially be changed (certainly black lints files in place
applying its opinionated style). When you then come to commit you may end up with the blame associated with code that
you only formatted. There are ways around this using Git's `--ignore-rev` flag to store commits in a file
`.git-blame-ignore-revs` that lists the hashes for which blame is to be ignored (see
[article](https://akrabat.com/ignoring-revisions-with-git-blame/))
:::

## Linting manually - `black`

```

```

::: {.notes}
:::

### Linting manually - `flake8`

```{.bash}
❱ flake8 sample.py
sample.py:1:1: D100 Missing docstring in public module
sample.py:1:1: F401 'numpy as np' imported but unused
sample.py:2:1: F401 'pandas as pd' imported but unused
sample.py:7:36: F821 undefined name 'Union'
sample.py:7:73: F821 undefined name 'List'
sample.py:8:80: E501 line too long (87 > 79 characters)
sample.py:9:80: E501 line too long (135 > 79 characters)
sample.py:12:5: E722 do not use bare 'except'
```

::: {.notes}
:::

### Linting manually - `pylint`

```{.bash}
❱ pylint sample.py
PYLINTHOME is now '/home/neil/.cache/pylint' but obsolescent '/home/neil/.pylint.d' is found; you can safely remove the latter
************* Module sample
sample.py:9:0: C0301: Line too long (135/120) (line-too-long)
sample.py:1:0: C0114: Missing module docstring (missing-module-docstring)
sample.py:7:35: E0602: Undefined variable 'Union' (undefined-variable)
sample.py:7:72: E0602: Undefined variable 'List' (undefined-variable)
sample.py:12:4: W0706: The except handler raises immediately (try-except-raise)
sample.py:4:0: C0411: standard import "from pathlib import Path" should be placed before "import numpy as np" (wrong-import-order)
sample.py:1:0: W0611: Unused numpy imported as np (unused-import)
sample.py:2:0: W0611: Unused pandas imported as pd (unused-import)

-------------------------------------
Your code has been rated at -10.00/10
```

::: {.notes}
:::

### Linting manually - `mypy`

```
❱ mypy sample.py
/home/neil/.virtualenvs/python3_10/lib/python3.10/site-packages/numpy/__init__.pyi:636: error: Positional-only parameters are only supported in Python 3.8 and greater
Found 1 error in 1 file (errors prevented further checking)
```

::: {.notes**
:::

## Testing

Tests ensure code works as expected.

**TODO** Write tests for above function.
```{.python}
```

### Testing - `pytest**

**TODO** Example of running tests.

```{.bash}
```
::: {.notes}
:::

## Linting with IDE

Popular IDEs have tools to run linting automatically on file save...

* Emacs : [blacken](https://github.com/pythonic-emacs/blacken) / [Flycheck](https://www.flycheck.org/en/latest/)
* VSCode : [Python](https://code.visualstudio.com/docs/python/linting) /
* PyCharm : [black](https://plugins.jetbrains.com/plugin/10563-black-pycharm) /
  [Mypy](https://plugins.jetbrains.com/plugin/11086-mypy) /
  [flake8](https://plugins.jetbrains.com/plugin/11563-flake8-support)
* RStudio : [lintr](https://lintr.r-lib.org/index.html)

::: {.notes}
Many popular Integrated Development Environments support linting of code on the fly or on saving files, Emacs has
`blacken` and `flycheck` modes, the later of which will run `flake8`.

VSCode has a Python module for linting.

PyCharm has plugins for `black`, `mypy` and `flake8`

RStudio has support for the `lintr` package (as does Emacs).

Using these tools is sensible as it can highlight quickly and early on problems with your code. Applying `black`
automatically also takes out some mental overhead in thinking about whether you are using the correct formatting whilst
writing code allowing you to focus on the problem you are trying to solve.
:::


## Committing

Ultimately you commit your changes then...

* Push to `origin`
* Open a Pull Request.
* See if test passes all CI tests.
* Await feedback and hopefully approval.

::: {.notes}
:::


## Problems

* Automated tests fail.
* Linting fails.


::: {.notes}
:::


## Pre-commit

*

::: {.notes}
This is where `pre-commit` comes to the rescue. Its a Python package that uses Git Hooks to run checks _before_ a commit
is made, hence the name! It can take care of running all the manual linting and tests for you and automate part of your
workflow.


Hooks are scripts that reside in `.git/hooks/`
:::
